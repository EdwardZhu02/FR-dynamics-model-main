import numpy as np

def waterbalance(su__, s_thetar, s_thetas, s_delz, i_no_veg, ruptkt__, ruptkg__, iovec, wlayer_):
    '''
    params :su__ : Soil saturation degree in each layer (-)
            s_thetar : Residual soil water content (-)
            s_thetas : Saturated soil water content (-)
            s_delz : Thickness of each soil layer (m)
            i_no_veg : Flag to switch vegetation off (1=no vegetation)
            ruptkt__ : Root water uptake rate perennial veg (m/s)
            ruptkg__ : Root water uptake rate seasonal veg (m/s)
            iovec : Mass balance for each soil layer (m/s)
            wlayer_ : Number of soil layers in unsaturated zone

    return : 



    TODO: this function is generated by chatgpt and need review.
    '''
    
    cH2Ol_s = (-su__ * s_thetar + su__ * s_thetas + s_thetar) * s_delz
    wc_ = np.sum(cH2Ol_s)

    inf__, infx__, qbl, esoil__, spgfcf__ = waterbalance_fluxes()

    if( i_no_veg  == 0): # Flag to switch vegetation off (1=no vegetation)
        io__     = inf__ - esoil__ - spgfcf__ - np.sum(ruptkt__) - np.sum(ruptkg__)  # (3.19)
    else:
        io__     = inf__ - esoil__ - spgfcf__  # (no vegetation, WB still needs to close)
    
    
    
    iovec.fill(0.0)
    
    iovec[0] = qbl[0] + inf__ - esoil__ - ruptkt__[0] - ruptkg__[0]
    if wlayer_ == 1:
        iovec[0] -= spgfcf__
    if wlayer_ > 2:
        for jj in range(1, wlayer_ - 1):
            iovec[jj] = qbl[jj] - qbl[jj-1] - ruptkt__[jj] - ruptkg__[jj]
    if wlayer_ > 1:
        iovec[wlayer_] = qbl[wlayer_] - qbl[wlayer_-1] - ruptkt__[wlayer_] - ruptkg__[wlayer_] - spgfcf__

    # change in saturation degree
    dsu = [-i / ((s_thetar[i] - s_thetas[i]) * s_delz[i]) for i in range(len(iovec))]

    # calculation of maximal time step size
    dt_, dtsu_count, dtmax_count = waterbalance_timestep(dsu, su__, wlayer_, dtmax)

    # Calculating state variables at next time step
    # (sunew, wlayernew, pcapnew, kunsatnew, zwnew)
    sunew, pcapnew, kunsatnew, zwnew = waterbalance_update_state(sunew, su__, dt_, s_maxlayer, sueq, s_avg, c_mvg, s_nvg, s_ksat, s_delz)

    waterbalance_diag()

# def waterbalance_init(i_cz, i_zr, s_delz, s_avg, s_nvg, c_mvg, s_ksat, s_thetar, s_thetas):\

#     # 初始化变量
#     dtsu_count = 0
#     dtmax_count = 0

#     zw_ = i_cz
#     wlayer_ = 0

#     # 确定层数
#     while zw_ > i_zr:
#         wlayer_ += 1
#         zw_ -= s_delz[wlayer_]

#     s_maxlayer = len(s_delz)
#     pcap_ = np.zeros(s_maxlayer)
    
#     # 计算平衡压力头
#     for jj in range(wlayer_, 0, -1):
#         pcap_[jj] = 0.5 * (s_delz[jj+1] + s_delz[jj]) + pcap_[jj+1]

#     sueq = np.zeros(s_maxlayer)
#     su__ = np.zeros(s_maxlayer)

#     # 计算平衡饱和度和当前饱和度
#     for jj in range(1, s_maxlayer):
#         sueq[jj] = (1 / ((0.5 * (s_delz[jj+1] + s_delz[jj]) * s_avg[jj]) ** s_nvg[jj] + 1)) ** c_mvg[jj]
    
#     sueq[s_maxlayer] = (1 / ((0.5 * s_delz[jj] * s_avg[jj]) ** s_nvg[jj] + 1)) ** c_mvg[jj]

#     su__ = (1 / ((pcap_ * s_avg) ** s_nvg + 1)) ** c_mvg

#     kunsat_ = ((-su__ ** (1 / c_mvg) + 1) ** c_mvg - 1) ** 2 * s_ksat * np.sqrt(su__)

#     cH2Ol_s = (-su__ * s_thetar + su__ * s_thetas + s_thetar) * s_delz

#     zwnew = zw_
#     wlayernew = wlayer_
#     pcapnew = pcap_
#     sunew = su__

#     return zwnew, wlayernew, pcapnew, sunew, kunsat_, cH2Ol_s 

def waterbalance_update_state(sunew, su__, dt_, s_maxlayer, sueq, s_avg, c_mvg, s_nvg, s_ksat, s_delz):
    '''
    params: sunew: Soil saturation degree in each layer at next time step (-)
            su__: Soil saturation degree in each layer (-)
            dt_: Length of time step (s)
            s_maxlayer: Number of soil layers
            sueq: Soil saturation degree above water table in hydrostatic equilibrium (-)
            s_avg: Van Genuchten soil parameter a (1/m)
            c_mvg: Van Genuchten soil parameter m (-)
            s_nvg: Van Genuchten soil parameter n (-)
            s_ksat: Saturated hydraulic conductivity (m/s)
            s_delz: Thickness of each soil layer (m)
    
    return: sunew:  Soil saturation degree in each layer at next time step (-)
            pcapnew: Matric pressure head in each layer at next time step (m)
            kunsatnew: Unsaturated hydraulic conductivity in each layer at next time step (m/s)
            zwnew: Elevation of water table at next time step (m)

    TODO: this function is generated by chatgpt and need review.
    '''
    wlayernew = s_maxlayer
    jj = s_maxlayer

    sunew[:] = su__[:] + dt_ * dsu[:]

    # Find the lowest unsaturated layer and set the one below it as wlayernew
    while sunew[jj] > 0.999999 and jj > 1:
        jj -= 1
        wlayernew = jj

    # If there is not enough moisture in the layer above the saturated layers, the water table is in the top saturated layer.
    if sunew[wlayernew] < sueq[wlayernew]:
        wlayernew += 1

    sunew[wlayernew+1:s_maxlayer] = 1.0

    pcapnew[:] = 1.0 / s_avg[:] * (sunew[:] ** (-1.0 / c_mvg[:]) - 1.0) ** (1.0 / s_nvg[:])

    kunsatnew[:] = s_ksat[:] * ((-sunew[:] ** (1.0 / c_mvg[:]) + 1.0) ** c_mvg[:] - 1.0) ** 2.0 * np.sqrt(sunew[:])

    # Position of the water table after eq_wt1 in watbal3
    if wlayernew < s_maxlayer:
        zwnew = np.sum(s_delz[wlayernew:s_maxlayer]) - 2.0 * s_delz[wlayernew] * pcapnew[wlayernew] / (s_delz[wlayernew+1] + s_delz[wlayernew])
    else:
        zwnew = s_delz[wlayernew] - 2.0 * s_delz[wlayernew] * pcapnew[wlayernew] / s_delz[wlayernew]

    return sunew, pcapnew, kunsatnew, zwnew

def waterbalance_timestep(dsu, su__, wlayer_, dtmax):
    '''
    params: dsu: Rate of change in soil saturation degree in each layer (1/s)
            su__: Soil saturation degree in each layer (-)
            wlayer_: Number of soil layers in unsaturated zone
            dtmax : Maximum time step (s)
            
    func:   epsilon: epsilon(x) 计算与 x 相同类型的最小数，详见百度 TODO: 实现这个函数

    return: dt_: Length of time step (s)
            dtsu_count, dtmax_count: For speed analysis, count of how often dtsu or dtmax is time limiting

    TODO: this function is generated by chatgpt and need review.
    '''
    dtsu = 999999.0
    dtsu_count = 0
    dtmax_count = 0

    for jj in range(wlayer_):
        if dsu[jj] < 0.0:
            dtsu = min(dtsu, -0.1 * su__[jj] / dsu[jj])
        if dsu[jj] > 0.0:
            dtsu = min(dtsu, 0.1 * su__[jj] / dsu[jj], (1.0 - su__[jj]) / dsu[jj])

        # dsu equal to zero
        if abs(dsu[jj]) < epsilon(dsu[jj]):
            dtsu = min(dtsu, 999999.0)

    dt_ = max(0.0, min(dtsu, dtmax))

    if dt_ <= epsilon(min(dtsu, dtmax)):
        raise ValueError("Error dt=0.0s")

    if dt_ == dtsu:
        dtsu_count += 1
    elif dt_ == dtmax:
        dtmax_count += 1

    return dt_, dtsu_count, dtmax_count

def waterbalance_fluxes(rain_h, th_, wlayer_, zw_, i_zr, su__):
    '''
    params: rain_h: Hourly rainfall rate (m/s)
            th_   : Hour since start of run
            wlayer_: Number of soil layers in unsaturated zone
            zw_ : Elevation of water table (m)
            i_zr : Average channel elevation (m)
            su__ : Soil saturation degree in each layer (-)
    
    return: inf__ : Infiltration rate (m/s)
            infx__: Infiltration excess runoff rate (m/s)
            qbl   : Water flux across bottom boundary of each layer (positive upwards) (m/s)
            esoil__: Bare soil evaporation rate (m/s)
            spgfcf__: Seepage face flow rate (m/s)

    TODO: this function is generated by chatgpt and need review.
    '''
    dummy = 0.0
    ii = 0
    jj = 0
    
    inf__ = 0.0
    infx__ = 0.0
    qbl = np.zeros(wlayer_)
    esoil__ = 0.0
    spgfcf__ = 0.0
    
    if rain_h(th_) > 0:
        if wlayer_ >= 1:
            inf__ = compute_infiltration(rain_h(th_))  # 根据实际公式计算入渗量
        else:
            inf__ = 0.0

        infx__ = rain_h(th_) - inf__

    if wlayer_ > 1:
        for jj in range(wlayer_-1):
            qbl[jj] = compute_unsaturated_flow(jj)  # 根据实际公式计算非饱和流的通量

    esoil__ = compute_soil_evaporation()  # 根据实际公式计算土壤蒸发量

    if zw_ > i_zr:
        spgfcf__ = compute_seepage_face_flow()  # 根据实际公式计算渗透面流的量

    if np.max(su__[0:wlayer_]) >= 1:
        if wlayer_ > 1:
            if su__[0] >= 0.99:
                dummy = compute_dummy(0, qbl[0])  # 根据实际公式计算dummy的值
                if qbl[0] - dummy > 0:
                    qbl[0] = dummy - 1e-16

            for ii in range(1, wlayer_-1):
                if su__[ii] >= 1:
                    dummy = compute_dummy(ii, qbl[ii])  # 根据实际公式计算dummy的值
                    if dummy > qbl[ii]:
                        qbl[ii] = dummy + 1e-16

        if su__[wlayer_] >= 1:
            dummy = compute_dummy(wlayer_, spgfcf__)  # 根据实际公式计算dummy的值
            spgfcf__ = max(spgfcf__, dummy + 1e-16)

    return inf__, infx__, qbl, esoil__, spgfcf__

# # 根据实际情况实现各个计算函数

def compute_infiltration(rainfall):
    # 实现入渗计算逻辑
    inf__ = 0.0
    # 计算inf__的值
    return inf__

def compute_unsaturated_flow(layer_index):
    # 实现非饱和流计算逻辑
    qbl = 0.0
    # 计算qbl的值
    return qbl

def compute_soil_evaporation():
    # 实现土壤蒸发计算逻辑
    esoil__ = 0.0
    # 计算esoil__的值
    return esoil__

def compute_seepage_face_flow():
    # 实现渗透面流计算逻辑
    spgfcf__ = 0.0
    # 计算spgfcf__的值
    return spgfcf__

def compute_dummy(layer_index, value):
    # 实现dummy计算逻辑
    dummy = 0.0
    # 计算dummy的值
    return dummy

# # 示例用法
# rainfall = 10.0
# th_ = 0.5
# wlayer_ = 3
# zw_ = 2.0
# i_zr = 1.0
# su__ = np.array([0.8, 1.2, 0.9])

# inf__, infx__, qbl, esoil__, spgfcf__ = waterbalance_fluxes(rainfall, th_, wlayer_, zw_, i_zr, su__)

# # 输出结果
# print("Infiltration:", inf__)
# print("Excess Rainfall:", infx__)
# print("Unsaturated Flow:", qbl)
# print("Soil Evaporation:", esoil__)
# print("Seepage Face Flow:", spgfcf__)